#!/usr/bin/env python3
"""
AAPT Secure Setup Script
Configura il framework AAPT con sicurezza avanzata
"""
import os
import sys
import secrets
import string
from cryptography.fernet import Fernet
import argparse

def generate_strong_password(length=32):
    """Genera una password forte"""
    alphabet = string.ascii_letters + string.digits + "!@#$%^&*"
    password = ''.join(secrets.choice(alphabet) for _ in range(length))
    return password

def generate_encryption_key():
    """Genera una chiave di crittografia"""
    return Fernet.generate_key().decode()

def create_env_file():
    """Crea file .env con credenziali sicure"""
    
    print("üîê Generando credenziali sicure...")
    
    # Genera credenziali
    rabbitmq_password = generate_strong_password()
    neo4j_password = generate_strong_password()
    encryption_key = generate_encryption_key()
    
    env_content = f"""# AAPT Secure Configuration
# Generated by setup_secure.py

# ===========================================
# SECRETS MANAGEMENT
# ===========================================
AAPT_ENCRYPTION_KEY={encryption_key}

# ===========================================
# RABBITMQ CONFIGURATION
# ===========================================
RABBITMQ_HOST=rabbitmq
RABBITMQ_USER=aapt_user
RABBITMQ_PASS={rabbitmq_password}
RABBITMQ_PORT=5672

# ===========================================
# NEO4J CONFIGURATION
# ===========================================
NEO4J_URI=bolt://neo4j:7687
NEO4J_USER=neo4j
NEO4J_PASS={neo4j_password}

# ===========================================
# API KEYS (Configure these manually)
# ===========================================
SHODAN_API_KEY=
CENSYS_API_ID=
CENSYS_API_SECRET=
NVD_API_KEY=

# ===========================================
# SLACK INTEGRATION (Optional)
# ===========================================
AAPT_SLACK_WEBHOOK=

# ===========================================
# LLM CONFIGURATION
# ===========================================
LLM_ROUTER_URL=http://llm-router:8082
MODEL_PATH=./models/
LLM_CONFIDENCE_THRESHOLD=0.6

# ===========================================
# OPSEC PROFILES
# ===========================================
AAPT_NMAP_TIMING=T3
AAPT_NMAP_RANDOMIZE_HOSTS=false
AAPT_MASSCAN_RATE=1000
AAPT_HTTPX_THREADS=50
AAPT_HTTPX_RATE_LIMIT=150
AAPT_SUBFINDER_RATE=100
AAPT_DNSX_RATE_LIMIT=1000

# ===========================================
# PASSIVE SCHEDULING
# ===========================================
AAPT_PASSIVE_INTERVAL=300
AAPT_SUBDOMAIN_REFRESH_HOURS=24
AAPT_HTTP_PROBE_REFRESH_HOURS=12

# ===========================================
# LOGGING
# ===========================================
LOG_LEVEL=INFO
"""
    
    # Path relativo alla directory principale del framework
    env_path = os.path.join('..', '.env')
    
    with open(env_path, 'w') as f:
        f.write(env_content)
    
    print("‚úÖ File .env creato con credenziali sicure")
    print(f"üìù RabbitMQ Password: {rabbitmq_password}")
    print(f"üìù Neo4j Password: {neo4j_password}")
    print(f"üîë Encryption Key: {encryption_key}")
    
    return rabbitmq_password, neo4j_password

def update_docker_compose(rabbitmq_password, neo4j_password):
    """Aggiorna docker-compose.yml con le nuove password"""
    
    print("üìù Aggiornando docker-compose.yml...")
    
    # Path relativo alla directory principale del framework
    docker_compose_path = os.path.join('..', 'docker-compose.yml')
    
    # Verifica che il file esista
    if not os.path.exists(docker_compose_path):
        print(f"‚ùå File {docker_compose_path} non trovato")
        return False
    
    # Leggi il file docker-compose.yml
    with open(docker_compose_path, 'r') as f:
        content = f.read()
    
    # Sostituisci le password
    content = content.replace('aapt_secret_pw', rabbitmq_password)
    content = content.replace('aapt_secret_db_pw', neo4j_password)
    
    # Scrivi il file aggiornato
    with open(docker_compose_path, 'w') as f:
        f.write(content)
    
    print("‚úÖ docker-compose.yml aggiornato")
    return True

def create_kubernetes_secrets(rabbitmq_password, neo4j_password):
    """Crea secrets Kubernetes"""
    
    print("‚ò∏Ô∏è  Creando secrets Kubernetes...")
    
    secrets_yaml = f"""apiVersion: v1
kind: Secret
metadata:
  name: aapt-secrets
  namespace: aapt
type: Opaque
stringData:
  rabbitmq-password: "{rabbitmq_password}"
  neo4j-password: "{neo4j_password}"
---
apiVersion: v1
kind: Secret
metadata:
  name: shodan-secret
  namespace: aapt
type: Opaque
stringData:
  api_key: "YOUR_SHODAN_API_KEY"
---
apiVersion: v1
kind: Secret
metadata:
  name: censys-secret
  namespace: aapt
type: Opaque
stringData:
  api_id: "YOUR_CENSYS_API_ID"
  api_secret: "YOUR_CENSYS_API_SECRET"
---
apiVersion: v1
kind: Secret
metadata:
  name: nvd-secret
  namespace: aapt
type: Opaque
stringData:
  api_key: "YOUR_NVD_API_KEY"
"""
    
    # Path relativo alla directory principale del framework
    secrets_path = os.path.join('..', 'k8s', 'secrets-secure.yaml')
    
    # Crea directory k8s se non esiste
    os.makedirs(os.path.dirname(secrets_path), exist_ok=True)
    
    with open(secrets_path, 'w') as f:
        f.write(secrets_yaml)
    
    print("‚úÖ Secrets Kubernetes creati in k8s/secrets-secure.yaml")

def create_directories():
    """Crea directory necessarie"""
    
    print("üìÅ Creando directory...")
    
    directories = [
        'logs',
        'models',
        'data',
        'backups'
    ]
    
    for directory in directories:
        # Path relativo alla directory principale del framework
        dir_path = os.path.join('..', directory)
        os.makedirs(dir_path, exist_ok=True)
        print(f"  ‚úÖ {directory}/")
        
        # Imposta permessi sicuri (funziona solo su Unix/Linux)
        try:
            os.chmod(dir_path, 0o750)
        except (OSError, AttributeError):
            # Su Windows chmod non funziona, ignora l'errore
            pass

def main():
    parser = argparse.ArgumentParser(description='Setup sicuro per AAPT Framework')
    parser.add_argument('--k8s', action='store_true', help='Crea anche secrets Kubernetes')
    parser.add_argument('--force', action='store_true', help='Sovrascrive file esistenti')
    
    args = parser.parse_args()
    
    print("üöÄ AAPT Secure Setup")
    print("=" * 50)
    
    # Controlla se .env esiste gi√†
    env_path = os.path.join('..', '.env')
    if os.path.exists(env_path) and not args.force:
        print("‚ùå File .env gi√† esistente. Usa --force per sovrascrivere.")
        return
    
    try:
        # Crea directory
        create_directories()
        
        # Genera credenziali e crea .env
        rabbitmq_password, neo4j_password = create_env_file()
        
        # Aggiorna docker-compose.yml
        if not update_docker_compose(rabbitmq_password, neo4j_password):
            print("‚ö†Ô∏è  Impossibile aggiornare docker-compose.yml, continua comunque...")
        
        # Crea secrets Kubernetes se richiesto
        if args.k8s:
            create_kubernetes_secrets(rabbitmq_password, neo4j_password)
        
        print("\nüéâ Setup completato con successo!")
        print("\nüìã Prossimi passi:")
        print("1. Configura le API keys nel file .env")
        print("2. Scarica i modelli LLM in ./models/")
        print("3. Esegui: docker-compose up -d")
        print("4. Verifica: http://localhost:5000")
        
        if args.k8s:
            print("\n‚ò∏Ô∏è  Per Kubernetes:")
            print("1. kubectl apply -f k8s/secrets-secure.yaml")
            print("2. kubectl apply -f k8s/")
        
    except Exception as e:
        print(f"‚ùå Errore durante setup: {e}")
        sys.exit(1)

if __name__ == '__main__':
    main()
